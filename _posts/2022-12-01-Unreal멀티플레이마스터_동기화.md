---
title: "언리얼 멀티플레이 동기화"
permalink: /posts/Unreal/
excerpt: "언리얼 멀티플레이 동기화"
last_modified_at: 2022-12-01T09:40:00-04:00
toc: true
---

# Moving Replication
## Moving Platform 추가하기
- StaticMeshActor를 상속받아 MovingPlatform클래스 생성
	- MovingPlatform.h
		``` C++
		#pragma once

		#include "CoreMinimal.h"
		#include "Engine/StaticMeshActor.h"
		#include "MovingPlatform.generated.h"
		UCLASS()
		class PUZZLEPLATFORMS_API AMovingPlatform : public AStaticMeshActor
		{
			GENERATED_BODY()
		public:
			AMovingPlatform();
			virtual void Tick(float DeltaTime) override;
		};
		```
	- MovingPlatform.cpp
		``` C++
		#include "MovingPlatform.h"
		
		AMovingPlatform::AMovingPlatform() {
			PrimaryActorTick.bCanEverTick = true;
		
			SetMobility(EComponentMobility::Movable);
		}

		void AMovingPlatform::Tick(float DeltaTime)
		{
			Super::Tick(DeltaTime);
			FVector Location = GetActorLocation();
			Location += FVector(5 * DeltaTime, 0, 0);
			SetActorLocation(Location);
		}
		```
		- SetMobility를 Movable로 지정해야 움직일 수 있음
- MovingPlatform을 씬에 드래그앤드롭하고 플레이하면 조금씩 움직이는 MovingPlatform확인 가능

 
## 만약 아래와 같은 컴파일 에러가 발생한다면?
- ![화면 캡처 2022-12-01 094835](https://user-images.githubusercontent.com/11372675/204940350-01051883-24cd-49fc-b085-e8270057da18.png)
- live coding설정이 활성화되어있기에 Visual Studio에서 Build를 하는 것이 아니라 UnrealProject에서 컴파일을 해야함
	- ![image](https://user-images.githubusercontent.com/11372675/204940945-1c50513e-2570-4a3d-a099-163718f4569c.png)
	- 오른쪽 하단에서 위와 같은 버튼을 찾아 클릭하자

## 내가 서버인가? 클라이언트인가?
- Actor를 상속받은 객체는 HasAuthority()라는 함수를 호출 가능
	- 반환값이 true라면 서버, false라면 client를 의미한다.

- MovingPlatform을 서버에서만 움직일 수 있도록 하자
	- MovingPlatform.h
		``` c++
		UPROPERTY(EditAnywhere)
		float Speed = 20;
		```
	- MovingPlatform.cpp
		``` c++
		void AMovingPlatform::Tick(float DeltaTime)
		{
			Super::Tick(DeltaTime);
			if (HasAuthority()) 
			{
				FVector Location = GetActorLocation();
				Location += FVector(Speed * DeltaTime, 0, 0);
				SetActorLocation(Location);
			}
		}
		```
	- 컴파일 후 실행해보면 클라이언트에서는 MovingPlatform이 움직이지 않음
		- 서버에서만 동작하고있고, 그것을 동기화해주겠다는 설정을 안 해주었기 때문

## Actor와 Replication
- Server가 replicated설정된 액터의 replicated설정된 상태를 변경하면 클라이언트에서도 상태가 동기화됨
- replicated되지 않았다면, 동기화되지 못한다.

- MovingPlatform은 서버에서 이동이 되고, 클라이언트들이 그 상태를 복제하도록 만들어야한다

- MovingPlatform
	- .h
		``` C++
		public:
			virtual void BeginPlay() override;	
		```
	- .cpp
		``` C++
		void AMovingPlatform::BeginPlay() {
			Super::BeginPlay();
			if (HasAuthority()) {
				SetReplicates(true);
				SetReplicateMovement(true);
			}
		}
		```
	- 게임이 시작하면 이 Actor를 replicate하겠다!
	- 이제 Client에서도 MovingPlatform이 움직인다.

	- 주의!
		- SetReplicate를 Client에서 하는 것은 Authority가 없기에 의미가 없음

- 그렇다면, Tick마다 움직이는 코드가 Client에서만 실행이 된다면?
	- Server에서는 MovingPlatform이 안 움직이고
	- Client에서는 MovingPlatform이 움직인다.
	- 이때, Client 플레이어가 Server의 MovingPlatform 위치로 이동하려 하면, 막혀서 갈 수 없다.
		- Server에서는 Client플레이어의 움직임을 MovingPlatform이 막고있다고 판단함
	- 또한, Client 플레이어가 Client에서 움직이는 MovingPlatform 위에 올라타려하면 떨어진다.
		- Server에서는 해당 위치에 MovingPlatform이 없다고 판단함
- 그렇다면, Tick마다 움직이는 속도가 Server와 Client에서 다르다면?
	``` C++
	void AMovingPlatform::Tick(float DeltaTime)
	{
		Super::Tick(DeltaTime);
		FVector Location = GetActorLocation();
		if (HasAuthority()) 
			Location += FVector(Speed * DeltaTime, 0, 0);
		else 
			Location += FVector(Speed * DeltaTime * 3, 0, 0);
		SetActorLocation(Location);
	}
	``` 
	- Server의 위치를 따르게 된다.
		- 동기화는 서버가 짱이다.
